package lightning_onion

import (
	"crypto/hmac"
	"crypto/sha256"

	"github.com/decred/dcrd/dcrec/secp256k1/v4"
	"golang.org/x/crypto/chacha20"
)

func (h HopPayload) Size() int {
	// 1 byte for the encoded payload length (assuming length is < 255)
	// plus actual bytes of payload + 32 bytes for the hmac
	return 1 + len(h.Payload) + 32
}

type HopPayload struct {
	PublicKey *secp256k1.PublicKey
	Payload   []byte
	Hmac      []byte
}

type Onion struct {
	Version     byte
	Point       [33]byte
	HopPayloads [1300]byte
	Hmac        [32]byte
}

func ConstructOnion(sessionKey *secp256k1.PrivateKey, hops []HopPayload) (*Onion, error) {
	numHops := len(hops)
	ephemeralPublicKeys := make([]*secp256k1.PublicKey, numHops)
	sharedSecrets := make([][]byte, numHops)
	blindingFactors := make([]*secp256k1.PrivateKey, numHops)

	currentkey := sessionKey

	// first need to compute the necessary keys to then construct the onion
	for i, hop := range hops {
		// for each hop need to compute a shared secret and the ephemeral key for the next hop
		ephemeralPublicKeys[i] = currentkey.PubKey()

		// shared secret is computed by doing ECDH exchange with the current ephemeral private key
		// and the hop's public key and then hashing (SHA256) that
		var pkpoint, ecdhpoint secp256k1.JacobianPoint
		hop.PublicKey.AsJacobian(&pkpoint)
		secp256k1.ScalarMultNonConst(&currentkey.Key, &pkpoint, &ecdhpoint)
		ecdhkey := secp256k1.NewPublicKey(&ecdhpoint.X, &ecdhpoint.Y)
		sharedSecret := sha256.Sum256(ecdhkey.SerializeCompressed())

		// the ephemeral private key for the next hop is computed by multiplying
		// the current ephemeral private key and a blinding factor
		// the blinding factor is the SHA256 of concatenating the current ephemeral public key and the shared secret
		blindingFactorHash := sha256.Sum256(append(currentkey.PubKey().SerializeCompressed(), sharedSecret[:]...))
		blindingFactor := secp256k1.PrivKeyFromBytes(blindingFactorHash[:])
		currentkey.Key.Mul(&blindingFactor.Key)

		sharedSecrets[i] = sharedSecret[:]
		blindingFactors[i] = blindingFactor
	}

	// initialize packet with 1300 random bytes
	padKey := generateKey(pad, sharedSecrets[0])
	packetBytes := generateRandomByteStream(padKey, 1300)
	nextHmac := make([]byte, 32)

	filler := generateFiller(hops, sharedSecrets)

	// packet construction is done backwards
	for i := numHops - 1; i >= 0; i-- {
		// used for generating pseudo-random byte stream to obfuscate (by xor-ing) payload at each hop
		rhoKey := generateKey(rho, sharedSecrets[i])
		// used to generate hmac
		muKey := generateKey(mu, sharedSecrets[i])

		hopPayloadLength := len(hops[i].Payload)
		shiftSize := hops[i].Size()

		hopPayload := make([]byte, 1, shiftSize)
		// NOTE: this length is wrong, should be bigsize encoding.
		hopPayload[0] = byte(hopPayloadLength)
		hopPayload = append(hopPayload, hops[i].Payload...)
		hopPayload = append(hopPayload, nextHmac...)

		rightShift(packetBytes, shiftSize)
		copy(packetBytes[:], hopPayload)

		// pseudo-random byte stream xor'd with `hop_payloads`
		byteStream := generateRandomByteStream(rhoKey, 1300)
		xor(packetBytes, packetBytes, byteStream)

		if i == numHops-1 {
			copy(packetBytes[len(packetBytes)-len(filler):], filler)
		}

		hmac := hmac.New(sha256.New, muKey)
		hmac.Write(packetBytes)
		nextHmac = hmac.Sum(nil)
	}

	var publickey [33]byte
	copy(publickey[:], ephemeralPublicKeys[0].SerializeCompressed())

	var hopPayloads [1300]byte
	copy(hopPayloads[:], packetBytes)

	var hmac [32]byte
	copy(hmac[:], nextHmac)

	return &Onion{
		Version:     0x00,
		Point:       publickey,
		HopPayloads: hopPayloads,
		Hmac:        hmac,
	}, nil
}

// each hop needs to decrypt the routing information intended for it
// but they need to generate more random data to obfuscate how far in
// the route is the packet
// generateFiller will be used by the origin node (sending)
// to generate the filler that will be generated by each hop
// so that the HMACs are computed and verified correctly
func generateFiller(hops []HopPayload, sharedSecrets [][]byte) []byte {
	fillerSize := 0
	// do not calculate for the last hop since it does not need to generate the HMAC
	for i := 0; i < len(hops)-1; i++ {
		fillerSize += 1 + len(hops[i].Payload) + 32
	}
	filler := make([]byte, fillerSize)

	for i := 0; i < len(hops)-1; i++ {
		// the difference between fillerEnd and fillerStart
		// is the number of bytes from the onion that have been "processed" until this hop
		// so that is the number of bytes that the current hop will obfuscate
		// while decrypting
		fillerStart := 1300
		for _, hop := range hops[:i] {
			fillerStart -= hop.Size()
		}
		fillerEnd := 1300 + hops[i].Size()

		rhoKey := generateKey(rho, sharedSecrets[i])
		byteStream := generateRandomByteStream(rhoKey, 2600)

		xor(filler, filler, byteStream[fillerStart:fillerEnd])
	}

	return filler
}

func generateRandomByteStream(key []byte, numBytes int) []byte {
	// 96-bit zero-nonce
	nonce := make([]byte, 12)
	byteStream := make([]byte, numBytes)
	cipher, err := chacha20.NewUnauthenticatedCipher(key, nonce)
	if err != nil {
		panic(err)
	}

	cipher.XORKeyStream(byteStream, byteStream)
	return byteStream
}

var (
	rho = []byte{0x72, 0x68, 0x6f}
	mu  = []byte{0x6d, 0x75}
	um  = []byte{0x75, 0x6d}
	pad = []byte{0x70, 0x61, 0x64}
)

// generate keys that will be used for encryption and verification:
// - rho
// - mu
// - um
// - pad
func generateKey(keyType []byte, secret []byte) []byte {
	hmac := hmac.New(sha256.New, keyType)
	hmac.Write(secret)
	key := hmac.Sum(nil)
	return key
}

// xor computes the byte wise XOR of a and b, storing the result in dst. Only
// the first `min(len(a), len(b))` bytes will be xor'd.
func xor(dst, a, b []byte) {
	n := len(a)
	if len(b) < n {
		n = len(b)
	}

	for i := 0; i < n; i++ {
		dst[i] = a[i] ^ b[i]
	}
}

// rightShift shifts the byte-slice by the given number of bytes to the right
// and 0-fill the resulting gap.
func rightShift(slice []byte, num int) {
	for i := len(slice) - num - 1; i >= 0; i-- {
		slice[num+i] = slice[i]
	}

	for i := 0; i < num; i++ {
		slice[i] = 0
	}
}
